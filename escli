#!/usr/bin/env python

# escli is a command line tool for interacting with Elasticsearch.
# It is written in Python
#
# Usage:
# escli [options] <command> [command-options]
#
# Commands:
#   ping        Ping the cluster
#   search      Search for documents in the cluster
#   get         Get a document by id
#   upload      Index document
#   delete      Delete documents
#   update      Update documents
#   count       Count documents
#   mlt         More Like This

import argparse
import json
import os
import sys
import warnings

import requests
import yaml

warnings.filterwarnings('ignore', message='Unverified HTTPS request')

home_dir = os.environ['HOME']
config_file = os.path.join(home_dir, '.escli.yaml')


def main():
    parser = argparse.ArgumentParser(description='Elasticsearch command-line interface')
    parser.add_argument('-v', '--verbose', action='store_true', dest='verbose', default=False, help='Verbose output')
    parser.add_argument('-s', '--server', dest='server', default=None, help='Elasticsearch host (default: read from config file, or https://localhost:9200)')
    parser.add_argument('-i', '--index', dest='index', default=None, help='Elasticsearch index')
    parser.add_argument('-k', '--api_key', dest='api_key', default=None, help='Elasticsearch API Key')
    parser.add_argument('-u', '--username', dest='username', default=None, help='Elasticsearch username')
    parser.add_argument('-P', '--password', dest='password', default=None, help='Elasticsearch password')
    parser.add_argument('-F', '--ca_fingerprint', dest='ca_fingerprint', default=None, help='CA Certificates fingerprint')
    parser.add_argument('-c', '--config', dest='config', default=config_file, help='Configuration file (default: $HOME/.escli.yaml)')
    subparsers = parser.add_subparsers(dest='command', title='commands', description='valid commands', help='additional help')

    subparsers.add_parser('ping', help='ping the Elasticsearch server')

    search_parser = subparsers.add_parser('search', help='search the Elasticsearch index')
    search_parser.add_argument('-q', '--query', type=str, dest='query', default=None, help='set the search query')

    get_parser = subparsers.add_parser('get', help='get a document from the Elasticsearch index')
    get_parser.add_argument('-id', '--document_id', type=str, dest='document_id', default=None, help='set the document ID')

    upload_parser = subparsers.add_parser('upload', help='upload documents to the Elasticsearch index')
    upload_parser.add_argument('-b', '--batchsize', type=int, dest='batchsize', default=50, help='Default batch size for uploading documents')
    upload_parser.add_argument('--key', type=str, dest='key', default=None, help='key of the document to use as the document ID')

    subparsers.add_parser('delete', help='delete documents from the Elasticsearch index')

    subparsers.add_parser('update', help='update/upsert documents in the Elasticsearch index')

    subparsers.add_parser('count', help='count the number of documents in the Elasticsearch index')

    mlt_parser = subparsers.add_parser('mlt', help='More Like This')
    mlt_parser.add_argument('-id', '--document_id', type=str, dest='document_id', default=None, help='set the document ID')
    mlt_parser.add_argument('-m', '--max_size', type=int, dest='max_size', default=50, help='set the maximum size of the result set')
    mlt_parser.add_argument('--max_query_terms', type=int, dest='max_query_terms', default=100, help='set the maximum number of query terms that will be selected')

    subparsers.add_parser('mappings', help='Add mappings to the index')

    subparsers.add_parser('drop', help='Drop the index')

    args, remaining = parser.parse_known_args()

    if not args.command:
        parser.print_help()
        parser.error('No command specified')

    configuration = configure(args)
    args.configuration = configuration

    if args.command == 'ping':
        ping_command(args, remaining)
    elif args.command == 'search':
        search_command(args, remaining)
    elif args.command == 'get':
        get_command(args, remaining)
    elif args.command == 'upload':
        upload_command(args, remaining)
    elif args.command == 'delete':
        delete_command(args, remaining)
    elif args.command == 'update':
        update_command(args, remaining)
    elif args.command == 'count':
        count_command(args, remaining)
    elif args.command == 'mlt':
        mlt_command(args, remaining)
    elif args.command == 'mappings':
        mappings_command(args, remaining)
    elif args.command == 'drop':
        drop_command(args, remaining)
    else:
        parser.error('Invalid command: %s' % args.command)


def ping_command(options, args):
    try:
        r = es_get_request(options, '/')
        x = r.json()
        x['ok'] = r.ok
        x['status'] = r.status_code
        x['server'] = options.configuration['ELASTICSEARCH_SERVER']
        print(jsonify(x))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))



def search_command(options, args):
    raise NotImplementedError('This function is not implemented yet')


def get_command(options, args):
    # accounts/#{id}
    if options.document_id is None:
        raise ValueError('Missing document ID')
    path = '/' + options.configuration['ELASTICSEARCH_INDEX'] + '/_doc/' + str(options.document_id)
    try:
        r = es_get_request(options, path)
        x = r.json()
        x['ok'] = r.ok
        x['status'] = r.status_code
        x['server'] = options.configuration['ELASTICSEARCH_SERVER']
        print(jsonify(x))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))


def upload_command(options, args):
    if options.key is None:
        raise ValueError('Missing key')
    if options.configuration['ELASTICSEARCH_INDEX'] is None:
        raise ValueError('Missing index')
    index = options.configuration['ELASTICSEARCH_INDEX']
    for batch in read_input_in_batches(options.batchsize):
        docs = []
        for line in batch:
            try:
                doc = json.loads(line)
                instruction = {"index":{"_index": index, "_id": doc[options.key]}}
                docs.append(instruction)
                docs.append(doc)
            except Exception as e:
                print(jsonify({'ok': False, 'error': str(e)}))
        try:
            r = es_request('post', options, '/_bulk', data='\n'.join([jsonify(d) for d in docs]) + '\n')
            x = r.json()
            items = x['items']
            x['items_added'] = len([i for i in items if i['index']['status'] == 201 or i['index']['status'] == 200])
            del x['items']
            x['ok'] = r.ok
            x['status'] = r.status_code
            x['server'] = options.configuration['ELASTICSEARCH_SERVER']
            print(jsonify(x))
        except Exception as e:
            print(jsonify({'ok': False, 'error': str(e)}))


def delete_command(options, args):
    raise NotImplementedError('This function is not implemented yet')


def update_command(options, args):
    raise NotImplementedError('This function is not implemented yet')


def count_command(options, args):
    # accounts/_count
    path = '/' + options.configuration['ELASTICSEARCH_INDEX'] + '/_count'
    try:
        r = es_get_request(options, path)
        x = r.json()
        x['ok'] = r.ok
        x['status'] = r.status_code
        x['server'] = options.configuration['ELASTICSEARCH_SERVER']
        x = remove_anon_keys(x)
        print(jsonify(x))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))

def mlt_command(options, args):
    if options.document_id is None:
        raise ValueError('Missing document ID')
    max_size = options.max_size
    max_query_terms = options.max_query_terms
    query = {"size": max_size, "query": {"more_like_this": {"like": [{"_index": options.configuration['ELASTICSEARCH_INDEX'], "_id": options.document_id}], "min_term_freq": 1, "max_query_terms": max_query_terms}}}
    path = '/' + options.configuration['ELASTICSEARCH_INDEX'] + '/_search'
    try:
        r = es_request('post', options, path, data=jsonify(query))
        x = r.json()
        hits = hits_hits(x)
        for hit in hits:
            print(jsonify(hit['_source']))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))


def mappings_command(options, args):
    if options.configuration['ELASTICSEARCH_INDEX'] is None:
        raise ValueError('Missing index')
    index = options.configuration['ELASTICSEARCH_INDEX']
    path = '/' + index
    # read the mappings from stdin
    mappings = json.loads(sys.stdin.read())
    # does it have a 'mappings' key?
    if 'mappings' not in mappings:
        mappings = {'mappings': mappings}
    # does it have a 'properties' key in the 'mappings' key?
    if 'properties' not in mappings['mappings']:
        raise ValueError('Missing "properties" key in "mappings"')
    try:
        r = es_request('put', options, path, data=jsonify(mappings))
        x = r.json()
        x['ok'] = r.ok
        x['status'] = r.status_code
        x['server'] = options.configuration['ELASTICSEARCH_SERVER']
        print(jsonify(x))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))


def drop_command(options, args):
    if options.configuration['ELASTICSEARCH_INDEX'] is None:
        raise ValueError('Missing index')
    index = options.configuration['ELASTICSEARCH_INDEX']
    path = '/' + index
    try:
        r = es_request('delete', options, path)
        x = r.json()
        x['ok'] = r.ok
        x['status'] = r.status_code
        x['server'] = options.configuration['ELASTICSEARCH_SERVER']
        print(jsonify(x))
    except Exception as e:
        print(jsonify({'ok': False, 'error': str(e)}))


# Utility functions


def read_input_in_batches(batch_size=50):
    batch = []
    for line in sys.stdin:
        batch.append(line.strip())
        if len(batch) == batch_size:
            yield batch
            batch = []
    if batch:
        yield batch

def remove_anon_keys(d):
    for k in list(d.keys()):
        if k.startswith('_'):
            del d[k]
    return d


def configure(options):
    config = {}
    if options.config is not None:
        config_file = options.config
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                config = yaml.safe_load(f)
    if options.server is not None:
        config['ELASTICSEARCH_SERVER'] = options.server
    if config['ELASTICSEARCH_SERVER'] is None:
        config['ELASTICSEARCH_SERVER'] = 'https://localhost:9200'
    if options.index is not None:
        config['ELASTICSEARCH_INDEX'] = options.index
    if options.api_key is not None:
        config['ELASTICSEARCH_API_KEY'] = options.api_key
    if options.username is not None:
        config['ELASTICSEARCH_USER'] = options.username
    if options.password is not None:
        config['ELASTICSEARCH_PASSWORD'] = options.password
    if options.ca_fingerprint is not None:
        config['ELASTICSEARCH_CERTIFICATE_FINGERPRINT'] = options.ca_fingerprint
    return config


def es_request(request_type, options, path, data=None):
    url = options.configuration['ELASTICSEARCH_SERVER'] + path
    headers = {}
    if options.configuration['ELASTICSEARCH_API_KEY'] is not None:
        headers['Authorization'] = 'ApiKey ' + options.configuration['ELASTICSEARCH_API_KEY']
    elif options.configuration['ELASTICSEARCH_USER'] is not None:
        headers['Authorization'] = 'Basic ' + options.configuration['ELASTICSEARCH_USER'] + ':' + options.configuration['ELASTICSEARCH_PASSWORD']
    if options.configuration['ELASTICSEARCH_CERTIFICATE_FINGERPRINT'] is not None:
        headers['X-SSL-CERTIFICATE-FINGERPRINT'] = options.configuration['ELASTICSEARCH_CERTIFICATE_FINGERPRINT']
    headers['Content-Type'] = 'application/json'
    if request_type == 'get':
        return requests.get(url, headers=headers, verify=False)
    if request_type == 'post':
        return requests.post(url, headers=headers, data=data, verify=False)
    if request_type == 'put':
        return requests.put(url, headers=headers, verify=False)
    if request_type == 'delete':
        return requests.delete(url, headers=headers, verify=False)
    raise ValueError('Invalid request type: %s' % request_type)


def es_get_request(options, path):
    return es_request('get', options, path)


def jsonify(obj):
    return json.dumps(obj, sort_keys=True)


def hits_hits(obj):
    if 'hits' in obj:
        if 'hits' in obj['hits']:
            return obj['hits']['hits']
    return obj


if __name__ == '__main__':
    main()
